{"version":3,"sources":["webpack://@verndale/toolkit/./node_modules/@coveo/atomic/dist/esm/accessibility-utils-2dcdb5aa.js","webpack://@verndale/toolkit/./node_modules/@coveo/atomic/dist/esm/atomic-aria-live_2.entry.js"],"names":[],"mappings":"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","file":"scripts/3804.bundle.js","sourcesContent":["import { b as buildCustomEvent } from './event-utils-5d69ba8f.js';\n\nconst findAriaLiveEventName = 'atomic/accessibility/findAriaLive';\nfunction AriaLiveRegion(regionName) {\n  function dispatchMessage(message) {\n    const event = buildCustomEvent(findAriaLiveEventName, {});\n    document.dispatchEvent(event);\n    const { element } = event.detail;\n    if (element) {\n      element.updateMessage(regionName, message);\n    }\n  }\n  return (component, setterName) => {\n    Object.defineProperty(component, setterName, {\n      set: (message) => dispatchMessage(message),\n    });\n  };\n}\nfunction FocusTarget() {\n  return (component, setterName) => {\n    const { componentWillLoad } = component;\n    component.componentWillLoad = function () {\n      componentWillLoad && componentWillLoad.call(this);\n      const { componentDidRender } = this;\n      let focusAfterSearch = false;\n      let focusOnNextTarget = false;\n      let onFocusCallback = null;\n      let lastSearchId = undefined;\n      let element = undefined;\n      this.componentDidRender = function () {\n        componentDidRender && componentDidRender.call(this);\n        if (!this.bindings) {\n          return;\n        }\n        if (focusAfterSearch &&\n          this.bindings.engine.state.search.response.searchUid !== lastSearchId) {\n          focusAfterSearch = false;\n          if (element) {\n            const el = element;\n            setTimeout(() => {\n              el.focus();\n              onFocusCallback === null || onFocusCallback === void 0 ? void 0 : onFocusCallback();\n            });\n          }\n        }\n      };\n      const focusTargetController = {\n        setTarget: (el) => {\n          if (!el) {\n            return;\n          }\n          element = el;\n          if (focusOnNextTarget) {\n            focusOnNextTarget = false;\n            element.focus();\n            onFocusCallback === null || onFocusCallback === void 0 ? void 0 : onFocusCallback();\n          }\n        },\n        focusAfterSearch: () => {\n          lastSearchId = this.bindings.engine.state.search.response.searchUid;\n          focusAfterSearch = true;\n          return new Promise((resolve) => (onFocusCallback = resolve));\n        },\n        focusOnNextTarget: () => {\n          focusOnNextTarget = true;\n          return new Promise((resolve) => (onFocusCallback = resolve));\n        },\n        disableForCurrentSearch: () => this.bindings.engine.state.search.response.searchUid !==\n          lastSearchId && (focusAfterSearch = false),\n      };\n      this[setterName] = focusTargetController;\n    };\n  };\n}\nfunction isFocusable(element) {\n  // Source: https://stackoverflow.com/a/30753870\n  if (element.getAttribute('tabindex') === '-1') {\n    return false;\n  }\n  if (element.hasAttribute('tabindex')) {\n    return true;\n  }\n  if (element.getAttribute('contentEditable') === 'true') {\n    return true;\n  }\n  switch (element.tagName) {\n    case 'A':\n    case 'AREA':\n      return element.hasAttribute('href');\n    case 'INPUT':\n    case 'SELECT':\n    case 'TEXTAREA':\n    case 'BUTTON':\n      return !element.hasAttribute('disabled');\n    case 'IFRAME':\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getFirstFocusableDescendant(element) {\n  if (isFocusable(element)) {\n    return element;\n  }\n  let children = Array.from(element.children);\n  if (element instanceof HTMLSlotElement) {\n    children = element.assignedElements();\n  }\n  else if (element.shadowRoot) {\n    children.push(...Array.from(element.shadowRoot.children));\n  }\n  for (const child of children) {\n    const focusableDescendant = getFirstFocusableDescendant(child);\n    if (focusableDescendant) {\n      return focusableDescendant;\n    }\n  }\n  return null;\n}\n\nexport { AriaLiveRegion as A, FocusTarget as F, findAriaLiveEventName as f, getFirstFocusableDescendant as g };\n\n//# sourceMappingURL=accessibility-utils-2dcdb5aa.js.map","import { r as registerInstance, h, g as getElement, H as Host } from './index-a326e2b3.js';\nimport { f as findAriaLiveEventName } from './accessibility-utils-2dcdb5aa.js';\nimport { t as PA } from './headless.esm-36d42fef.js';\nimport './event-utils-5d69ba8f.js';\n\nconst AtomicAriaLive = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.message = '';\n  }\n  onFindAriaLive(args) {\n    if (!args.element || !this.isInSearchInterface) {\n      args.element = this.host;\n    }\n  }\n  get isInSearchInterface() {\n    let element = this.host;\n    while (element) {\n      if (element.tagName === 'ATOMIC-SEARCH-INTERFACE') {\n        return true;\n      }\n      element = element.parentElement;\n    }\n    return false;\n  }\n  /**\n   * @internal\n   */\n  async updateMessage(region, message) {\n    const wouldOverwriteAnotherRegion = region !== this.lastUpdatedRegion;\n    if (wouldOverwriteAnotherRegion) {\n      this.lastUpdatedRegion = region;\n      if (!message) {\n        return;\n      }\n    }\n    this.message = message;\n  }\n  connectedCallback() {\n    const eventListener = (ev) => this.onFindAriaLive(ev.detail);\n    document.addEventListener(findAriaLiveEventName, eventListener);\n    this.disconnectFindAriaLiveEvent = () => document.removeEventListener(findAriaLiveEventName, eventListener);\n  }\n  disconnectedCallback() {\n    var _a;\n    (_a = this.disconnectFindAriaLiveEvent) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  render() {\n    return (h(Host, { style: { position: 'absolute', right: '10000px' }, \"aria-live\": \"polite\", role: \"status\" }, this.message));\n  }\n  get host() { return getElement(this); }\n};\n\nconst AtomicRelevanceInspector = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.unsubscribe = () => { };\n    this.relevanceInspector = PA(this.bindings.engine, {\n      initialState: {\n        // TODO: add enable/disable mechanism\n        enabled: false,\n      },\n    });\n    this.unsubscribe = this.relevanceInspector.subscribe(() => (this.relevanceInspectorState = this.relevanceInspector.state));\n  }\n  disconnectedCallback() {\n    this.unsubscribe();\n  }\n  render() {\n    if (!this.relevanceInspectorState.isEnabled) {\n      return;\n    }\n    // TODO: Display data in a cleaner manner\n    return (h(\"p\", null, \"Debug mode is enabled. Look at the developper console to see additional information.\"));\n  }\n};\n\nexport { AtomicAriaLive as atomic_aria_live, AtomicRelevanceInspector as atomic_relevance_inspector };\n\n//# sourceMappingURL=atomic-aria-live_2.entry.js.map"],"sourceRoot":""}