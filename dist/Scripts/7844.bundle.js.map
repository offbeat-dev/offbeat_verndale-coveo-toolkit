{"version":3,"sources":["webpack://@verndale/toolkit/./node_modules/@coveo/atomic/dist/esm/atomic-field-condition.entry.js","webpack://@verndale/toolkit/./node_modules/@coveo/atomic/dist/esm/props-utils-fc565e68.js"],"names":[],"mappings":"yQASA,KAAM,GAA0B,yCAEhC,GAAI,GAAoD,SAAU,EAAY,EAAQ,EAAK,EAAM,CAC/F,GAAI,GAAI,UAAU,OAAQ,EAAI,EAAI,EAAI,EAAS,IAAS,KAAO,EAAO,OAAO,yBAAyB,EAAQ,GAAO,EAAM,EAC3H,GAAI,MAAO,UAAY,UAAY,MAAO,SAAQ,UAAa,WAC7D,EAAI,QAAQ,SAAS,EAAY,EAAQ,EAAK,OAE9C,QAAS,GAAI,EAAW,OAAS,EAAG,GAAK,EAAG,IACtC,GAAI,EAAW,KACjB,GAAK,GAAI,EAAI,EAAE,GAAK,EAAI,EAAI,EAAE,EAAQ,EAAK,GAAK,EAAE,EAAQ,KAAS,GACzE,MAAO,GAAI,GAAK,GAAK,OAAO,eAAe,EAAQ,EAAK,GAAI,GAE9D,KAAM,GAAuB,KAAM,CACjC,YAAY,EAAS,CACnB,QAAiB,KAAM,GAOvB,KAAK,WAAa,GAMlB,KAAK,UAAY,GAMjB,KAAK,aAAe,GACpB,KAAK,gBAAkB,GAEzB,mBAAoB,CAClB,GAAI,KAAK,UAAW,CAClB,KAAM,GAAa,KAAK,UAAU,MAAM,KACxC,KAAK,WAAW,KAAK,wBAAuB,IAE9C,GAAI,KAAK,aAAc,CACrB,KAAM,GAAa,KAAK,aAAa,MAAM,KAC3C,KAAK,WAAW,KAAK,2BAA0B,IAEjD,SAAW,KAAS,MAAK,UACvB,KAAK,WAAW,KAAK,mBAAkB,EAAO,KAAK,UAAU,KAE/D,SAAW,KAAS,MAAK,aACvB,KAAK,WAAW,KAAK,sBAAqB,EAAO,KAAK,aAAa,KAGvE,QAAS,CACP,MAAK,MAAK,WAAW,MAAO,GAAc,EAAU,KAAK,SAIlD,QAAE,OAAQ,MAHf,MAAK,gBAAkB,GAChB,IAIX,kBAAmB,CACjB,KAAK,iBAAmB,KAAK,KAAK,YAEhC,OAAO,CAAE,MAAO,QAAW,QAEjC,EAAW,CACT,QAAQ,CAAE,YAAa,MACtB,EAAqB,UAAW,YAAa,QAChD,EAAW,CACT,QAAQ,CAAE,YAAa,MACtB,EAAqB,UAAW,eAAgB,QACnD,EAAW,CACT,WACC,EAAqB,UAAW,SAAU,QAC7C,EAAqB,MAAQ,G,gFC/E7B,WAAiB,EAAM,CACrB,MAAO,CAAC,EAAW,IAAiB,CAClC,KAAM,CAAE,qBAAsB,EAC9B,GAAI,CAAC,EAAmB,CACtB,QAAQ,MAAM,iGACd,OAEF,EAAU,kBAAoB,UAAY,CACxC,GAAI,GACJ,KAAM,GAAU,GAAQ,EAAK,iBAAoB,EAC3C,EAAW,KAAK,GAChB,EAAa,QAAW,MAAM,WACpC,EAAoB,EAAQ,EAAU,MAAM,KAAK,GAAc,GAAK,GAAS,KAA0B,OAAS,EAAK,eAAiB,MAAQ,IAAO,OAAS,EAAK,IACnK,EAAkB,KAAK,QAI7B,WAA6B,EAAQ,EAAa,EAAY,EAAa,CACzE,KAAM,GAAM,EAAsB,EAAQ,GAC1C,OAAO,OAAO,EAAa,EAAc,EAA0B,GAAO,GAE5E,WAAmC,EAAK,CACtC,MAAO,QAAO,QAAQ,GAAK,OAAO,CAAC,EAAK,CAAC,EAAK,KAAY,KACrD,GACF,GAAM,EAAM,MAAM,KAAK,IAAK,GAAa,EAAS,UACjD,IAEN,WAA+B,EAAQ,EAAY,CACjD,KAAM,GAAc,GACd,EAAc,QAAa,GAAU,IAC3C,OAAS,GAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CAC1C,KAAM,GAAY,EAAW,GAC7B,GAAI,EAAU,KAAK,QAAQ,KAAiB,EAC1C,SAEF,KAAM,GAAW,QAAa,EAAU,KAAK,QAAQ,EAAa,KAClE,EAAY,GAAY,GAAG,EAAU,QAEvC,MAAO","file":"scripts/7844.bundle.js","sourcesContent":["import { r as registerInstance, h, g as getElement } from './index-a326e2b3.js';\nimport { k as kS } from './headless.esm-36d42fef.js';\nimport { R as ResultContext } from './result-template-decorators-0969aa55.js';\nimport { M as MapProp } from './props-utils-fc565e68.js';\nimport './event-utils-5d69ba8f.js';\nimport './utils-2f0ee174.js';\nimport './purify-e45d59ef.js';\nimport './_commonjsHelpers-5ec8f9b7.js';\n\nconst atomicFieldConditionCss = \"atomic-field-condition{max-width:100%}\";\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst AtomicFieldCondition = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * A function that must return true on results for the result template to apply.\n     *\n     * For example, a template with the following condition only applies to results whose `title` contains `singapore`:\n     * `[(result) => /singapore/i.test(result.title)]`\n     */\n    this.conditions = [];\n    /**\n     * The field and values that define which result items the condition must be applied to.\n     *\n     * For example, a template with the following attribute only applies to result items whose `filetype` is `lithiummessage` or `YouTubePlaylist`: `must-match-filetype=\"lithiummessage,YouTubePlaylist\"`\n     */\n    this.mustMatch = {};\n    /**\n     * The field and values that define which result items the condition must not be applied to.\n     *\n     * For example, a template with the following attribute only applies to result items whose `filetype` is not `lithiummessage`: `must-not-match-filetype=\"lithiummessage\"`\n     */\n    this.mustNotMatch = {};\n    this.shouldBeRemoved = false;\n  }\n  componentWillLoad() {\n    if (this.ifDefined) {\n      const fieldNames = this.ifDefined.split(',');\n      this.conditions.push(kS.fieldsMustBeDefined(fieldNames));\n    }\n    if (this.ifNotDefined) {\n      const fieldNames = this.ifNotDefined.split(',');\n      this.conditions.push(kS.fieldsMustNotBeDefined(fieldNames));\n    }\n    for (const field in this.mustMatch) {\n      this.conditions.push(kS.fieldMustMatch(field, this.mustMatch[field]));\n    }\n    for (const field in this.mustNotMatch) {\n      this.conditions.push(kS.fieldMustNotMatch(field, this.mustNotMatch[field]));\n    }\n  }\n  render() {\n    if (!this.conditions.every((condition) => condition(this.result))) {\n      this.shouldBeRemoved = true;\n      return '';\n    }\n    return h(\"slot\", null);\n  }\n  componentDidLoad() {\n    this.shouldBeRemoved && this.host.remove();\n  }\n  get host() { return getElement(this); }\n};\n__decorate([\n  MapProp({ splitValues: true })\n], AtomicFieldCondition.prototype, \"mustMatch\", void 0);\n__decorate([\n  MapProp({ splitValues: true })\n], AtomicFieldCondition.prototype, \"mustNotMatch\", void 0);\n__decorate([\n  ResultContext()\n], AtomicFieldCondition.prototype, \"result\", void 0);\nAtomicFieldCondition.style = atomicFieldConditionCss;\n\nexport { AtomicFieldCondition as atomic_field_condition };\n\n//# sourceMappingURL=atomic-field-condition.entry.js.map","import { g as getElement } from './index-a326e2b3.js';\nimport { a as camelToKebab, k as kebabToCamel } from './utils-2f0ee174.js';\n\nfunction MapProp(opts) {\n  return (component, variableName) => {\n    const { componentWillLoad } = component;\n    if (!componentWillLoad) {\n      console.error('The \"componentWillLoad\" lifecycle method has to be defined for the MapProp decorator to work.');\n      return;\n    }\n    component.componentWillLoad = function () {\n      var _a;\n      const prefix = (opts && opts.attributePrefix) || variableName;\n      const variable = this[variableName];\n      const attributes = getElement(this).attributes;\n      mapAttributesToProp(prefix, variable, Array.from(attributes), (_a = opts === null || opts === void 0 ? void 0 : opts.splitValues) !== null && _a !== void 0 ? _a : false);\n      componentWillLoad.call(this);\n    };\n  };\n}\nfunction mapAttributesToProp(prefix, mapVariable, attributes, splitValues) {\n  const map = attributesToStringMap(prefix, attributes);\n  Object.assign(mapVariable, splitValues ? stringMapToStringArrayMap(map) : map);\n}\nfunction stringMapToStringArrayMap(map) {\n  return Object.entries(map).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: value.split(',').map((subValue) => subValue.trim()),\n  }), {});\n}\nfunction attributesToStringMap(prefix, attributes) {\n  const mapVariable = {};\n  const kebabPrefix = camelToKebab(prefix) + '-';\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.name.indexOf(kebabPrefix) !== 0) {\n      continue;\n    }\n    const property = kebabToCamel(attribute.name.replace(kebabPrefix, ''));\n    mapVariable[property] = `${attribute.value}`;\n  }\n  return mapVariable;\n}\n\nexport { MapProp as M };\n\n//# sourceMappingURL=props-utils-fc565e68.js.map"],"sourceRoot":""}